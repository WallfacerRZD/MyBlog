##问题的起源
今天博主在用Java实现算法时,写了这样的代码:  
Java:  
```
	private static void exchange(int x, int y){
		int temp = x;
		x = y;
		y = temp;
	}
```  
想调用`exchange(a, b)`交换变量a, b的值  
运行后发现a,b的值并没有交换  
然后再看了一眼上面的代码,心里默念  
MDZZ!!  
函数的参数传递的是值传递,变量x,y, temp, 是函数的局部变量是外部变量a, b的拷贝,交换x,y.并不改变a, b的值啊!!!.  

然而冷静下来的博主,眉头一皱发现事情并不简单.  
我开始思考我为什么会写出这么ZZ的代码,后来想到以前用c++写过相似的代码  
c++:  
```  
void exchange(int &x, int &y) {  
	int temp = x;  
	x = y;  
	y = temp;  
}
```  
运行`exchange(a, b);`发现a,b的值确实交换了  
原来是想到Java的变量叫引用变量,应该和c++里的引用差不多,既然c++用引用参数可以做到,那么Java直接用变量做参数也可以做到.  
想到这里为自己写出这样ZZ代码找到了一个合理的借口  
(住口!!你就是菜!!!)  
##问题的探究
博主想度娘请教后,发现了比较好的解释,下面引用知乎用户的回答  

作者：Jack Tan
链接：https://www.zhihu.com/question/31203609/answer/51473602
来源：知乎

>1. = 是赋值操作（任何包含=的如+=、-=、 /=等等，都内含了赋值操作）。不再是你以前理解的数学含义了，而+ - * /和 = 在java中更不是一个级别，换句话说， = 是一个动作，一个可以改变内存状态的操作，一个可以改变变量的符号，而+ - * /却不会。这里的赋值操作其实是包含了两个意思：1、放弃了原有的值或引用；2、得到了 = 右侧变量的值或引用。Java中对 = 的理解很重要啊！！可惜好多人忽略了，或者理解了却没深思过。
>2. 对于基本数据类型变量，= 操作是完整地复制了变量的值。换句话说，“=之后，你我已无关联”；至于基本数据类型，就不在这科普了。
>3. 对于非基本数据类型变量，= 操作是复制了变量的引用。换句话说，“嘿，= 左侧的变量，你丫别给我瞎动！咱俩现在是一根绳上的蚂蚱，除非你再被 = 一次放弃现有的引用！！上面说了 = 是一个动作，所以我把 = 当作动词用啦！！”。而非基本数据类型变量你基本上可以参数本身是变量，参数传递本质就是一种 = 操作。
>4. 参数是变量，所有我们对变量的操作、变量能有的行为，参数都有。所以把C语言里参数是传值啊、传指针啊的那套理论全忘掉，参数传递就是 = 操作。

结合上面的回答相信大家都已经清楚Java代码为什么出现问题了.(int 是基本Java的基本类型,参数传递时`x = a`把a的值赋值给x,赋值后x和a没有关系了)

为什么c++代码能正常运行呢?  
<<c++primer>>里这样说:  
>引用并非对象,相反的,它只是为一个已经存在的对象所起的另外一个名字.  

c++的引用在内部是用指针实现的,可以理解为对象的别名.在函数内部,对x,y的所有操作可以等价于对a,b的操作.  

##总结
1. Java和c++的 '=' 运算有很大区别:
c++中'='是把左边变量的值擦掉,赋值为右边变量的值(赋值).
Java中的'='是左边变量放弃了原有的值或引用,然后得到了 = 右侧变量的值(基本类型)或引用(非基本类型)
2. Java的参数传递和参数的类型有关,可以理解为:
当参数是基本类型(byte, short, int, long,float, double,boolean,char)时是值传递,非基本类型是引用传递.
3. 在c++中当参数为引用时,是引用传递,其余情况都是值传递.

由于博主也是初学者,写博客是为了记录在学习过程中遇到的问题和总结经验.如果你和我有相同的思考,并且能帮助到你那就在好不过了.




